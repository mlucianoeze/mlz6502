# mlz6502

[README in English](README.en.md).

Era viernes a la noche, estaba tomándome un vinito en casa y charlando con un amigo sobre lo fantástica que es la gente que escribe emuladores, cuando en un momento de locura y desquicio pensé: "Qué me impide a mí hacer un emulador?" Así que se me ocurrió la loca idea de encarar un proyectito de ese estilo.

Por suerte, tengo medianamente frescos los conocimientos que hacen falta para crear mi propio emulador: entender el funcionamiento de un procesador, cómo interactúa con el resto de sus componentes, cómo se define un set de instrucciones y cómo se implementa electrónicamente. Al mismo tiempo, me siento cómodo con proyectos de muy bajo nivel, con algunas aficiones poco sanas como el kernel de Linux, y también con experiencia profesional en proyectos low-level que me enseñaron a moverme por estos terrenos.

Fue entonces cuando me aventuré con el plan y empecé por algo sencillo: el mítico 6502. Una arquitectura simple, un set de instrucciones acotado pero completo, y una posibilidad inmensa de extenderlo a implementaciones interesantísimas como la Apple II, la Commodore VIC-20 o hasta la Commodore 64, la NES, y mucho mucho más. Yo que soy un loco fanático de Nintendo, imaginate si no iba a aprovechar la oportunidad.

La cosa es que también soy back-end developer hace muchísimos años, así que mi experiencia profesional me llevó por muchos lugares con aroma a Java, con arquitecturas limpias y código prolijo (en no tantos casos, por supuesto). Esto despertó en mí la imperiosa necesidad de dotar a mi emulador de arquitecturas y abstracciones que hicieran del código algo estéticamente lindo, entendible, autodocumentado y mantenible. Toda esta expresividad es, como mínimo, innecesaria; basta con leer el código de los proyectos low-level más exitosos para entender que la simpleza en la implementación, por momentos, le gana a las abstracciones rimbombantes: a veces, menos es más. Justamente por esta razón, me interesó diferenciarme de otros proyectos que se enfocan en la simpleza y la performance, para en su lugar abordar un gran experimento que podemos resumir en una pregunta: qué pasaría si un back-end developer decidiera hacer un emulador? O sea, ver qué tan lejos se puede llegar con el mindset arquitectural de un _backender_.

Para eso, no iba a escribir el emulador con Java y Spring Boot, así que en su lugar elegí usar Rust. Es bien low-level como C o C++, ofrece la memory-safety que tanto me gusta (sin poner a andar un garbage collector como Go), y sobre todo, resuelve muchas abstracciones en tiempo de compilación, lo que deja un binario limpio y sin toda la parafernalia arquitectónica que quiero usar (y que la verdad, no aporta nada al runtime, sino que más bien es una herramienta para el desarrollador y su comodidad a la hora de trabajar con el código).

En fin, la gracia de este código es que lo construí sin saber cómo funcionan los emuladores hoy en día. O sea: jamás vi el código de uno. Lo hice según mi propia interpretación de cómo creo que se vería uno, y tiene algún que otro decorado propio que lo hace más interesante.

Disfruté muchísimo pensar y plantear esta arquitectura tan curiosa, basada por ejemplo en que no se implementan los opcodes de a uno, sino que según la instrucción y sus modos de direccionamiento soportados, se arma un conjunto de combos (_variants_) que se corresponden a los opcodes. Esto me pareció bastante práctico para no tener que preocuparme por implementar cada variante, y dejar que el modo de direccionamiento abstraiga esa parte, en una suerte de pipe que le entrega a la implementación de la instrucción todos los datos que necesita.

De más está decir que este proyecto todavía no está terminado: tiene muy pocas instrucciones implementadas, faltan modos de direccionamiento, manejo de interrupciones, y sobre todo el famoso _decimal mode_ del 6502. Igualmente, estas son cosas que iré implementando de a poco, siempre y cuando mi tiempo ocioso (y mis ganas de quemarlo en este desquicio) me lo permitan.
